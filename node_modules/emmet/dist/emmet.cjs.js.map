{"version":3,"file":"emmet.cjs.js","sources":["../packages/scanner/scanner.es.js","../packages/abbreviation/dist/abbreviation.es.js","../packages/css-abbreviation/node_modules/@emmetio/scanner/scanner.es.js","../packages/css-abbreviation/dist/css-abbreviation.es.js","../src/markup/attributes.ts","../src/markup/utils.ts","../src/markup/snippets.ts","../src/output-stream.ts","../src/markup/implicit-tag.ts","../src/markup/lorem/latin.json","../src/markup/lorem/russian.json","../src/markup/lorem/spanish.json","../src/markup/lorem/index.ts","../src/markup/addon/jsx.ts","../src/markup/addon/xsl.ts","../src/markup/addon/bem.ts","../src/markup/format/walk.ts","../src/markup/format/utils.ts","../src/markup/format/template.ts","../src/markup/format/comment.ts","../src/markup/format/html.ts","../src/markup/format/indent-format.ts","../src/markup/format/haml.ts","../src/markup/format/slim.ts","../src/markup/format/pug.ts","../src/markup/index.ts","../src/stylesheet/snippets.ts","../src/stylesheet/score.ts","../src/stylesheet/color.ts","../src/stylesheet/format.ts","../src/stylesheet/index.ts","../snippets/html.json","../snippets/css.json","../snippets/xsl.json","../snippets/variables.json","../src/config.ts","../src/extract-abbreviation/reader.ts","../src/extract-abbreviation/quotes.ts","../src/extract-abbreviation/is-html.ts","../src/extract-abbreviation/index.ts","../src/index.ts"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign({}, defaultQuotedOptions, options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign({}, defaultQuotedOptions, options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n            return result;\n        }\n        throw error(scanner, 'Expecting )', token);\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        if (scanner.eof()) {\n            scanner.start = scanner.pos - 1;\n        }\n        else {\n            scanner.start = scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = field(scanner, ctx)\n            || repeaterPlaceholder(scanner)\n            || repeaterNumber(scanner)\n            || repeater$1(scanner)\n            || whiteSpace(scanner)\n            || literal$1(scanner, ctx)\n            || operator(scanner)\n            || quote(scanner)\n            || bracket(scanner);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression && (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch))) {\n            // Stop for characters not allowed in unquoted literal\n            break;\n        }\n        value += escaped(scanner)\n            ? scanner.current()\n            : scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace() {\n        return ' ';\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                textInserted = true;\n                const value = Array.isArray(options.text)\n                    ? (pos != null ? options.text[pos] : options.text.join('\\n'))\n                    : options.text;\n                return value != null ? value : '';\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.text.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","const defaultQuotedOptions = {\r\n    escape: 92,\r\n    throws: false\r\n};\r\n/**\r\n * Check if given code is a number\r\n */\r\nfunction isNumber(code) {\r\n    return code > 47 && code < 58;\r\n}\r\n/**\r\n * Check if given character code is alpha code (letter through A to Z)\r\n */\r\nfunction isAlpha(code, from, to) {\r\n    from = from || 65; // A\r\n    to = to || 90; // Z\r\n    code &= ~32; // quick hack to convert any char code to uppercase char code\r\n    return code >= from && code <= to;\r\n}\r\n/**\r\n * Check if given character code is alpha-numeric (letter through A to Z or number)\r\n */\r\nfunction isAlphaNumeric(code) {\r\n    return isNumber(code) || isAlpha(code);\r\n}\r\nfunction isAlphaNumericWord(code) {\r\n    return isNumber(code) || isAlphaWord(code);\r\n}\r\nfunction isAlphaWord(code) {\r\n    return code === 95 /* _ */ || isAlpha(code);\r\n}\r\n/**\r\n * Check if given character code is a white-space character: a space character\r\n * or line breaks\r\n */\r\nfunction isWhiteSpace(code) {\r\n    return code === 32 /* space */\r\n        || code === 9 /* tab */\r\n        || code === 160; /* non-breaking space */\r\n}\r\n/**\r\n * Check if given character code is a space character\r\n */\r\nfunction isSpace(code) {\r\n    return isWhiteSpace(code)\r\n        || code === 10 /* LF */\r\n        || code === 13; /* CR */\r\n}\r\n/**\r\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\r\n * @return `true` if quoted string was consumed. The contents of quoted string\r\n * will be available as `stream.current()`\r\n */\r\nfunction eatQuoted(stream, options) {\r\n    options = Object.assign({}, defaultQuotedOptions, options);\r\n    const start = stream.pos;\r\n    const quote = stream.peek();\r\n    if (stream.eat(isQuote)) {\r\n        while (!stream.eof()) {\r\n            switch (stream.next()) {\r\n                case quote:\r\n                    stream.start = start;\r\n                    return true;\r\n                case options.escape:\r\n                    stream.next();\r\n                    break;\r\n            }\r\n        }\r\n        // If we’re here then stream wasn’t properly consumed.\r\n        // Revert stream and decide what to do\r\n        stream.pos = start;\r\n        if (options.throws) {\r\n            throw stream.error('Unable to consume quoted string');\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Check if given character code is a quote character\r\n */\r\nfunction isQuote(code) {\r\n    return code === 39 /* ' */ || code === 34 /* \" */;\r\n}\r\n/**\r\n * Eats paired characters substring, for example `(foo)` or `[bar]`\r\n * @param open Character code of pair opening\r\n * @param close Character code of pair closing\r\n * @return Returns `true` if character pair was successfully consumed, it’s\r\n * content will be available as `stream.current()`\r\n */\r\nfunction eatPair(stream, open, close, options) {\r\n    options = Object.assign({}, defaultQuotedOptions, options);\r\n    const start = stream.pos;\r\n    if (stream.eat(open)) {\r\n        let stack = 1;\r\n        let ch;\r\n        while (!stream.eof()) {\r\n            if (eatQuoted(stream, options)) {\r\n                continue;\r\n            }\r\n            ch = stream.next();\r\n            if (ch === open) {\r\n                stack++;\r\n            }\r\n            else if (ch === close) {\r\n                stack--;\r\n                if (!stack) {\r\n                    stream.start = start;\r\n                    return true;\r\n                }\r\n            }\r\n            else if (ch === options.escape) {\r\n                stream.next();\r\n            }\r\n        }\r\n        // If we’re here then paired character can’t be consumed\r\n        stream.pos = start;\r\n        if (options.throws) {\r\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * A streaming, character code-based string reader\r\n */\r\nclass Scanner {\r\n    constructor(str, start, end) {\r\n        if (end == null && typeof str === 'string') {\r\n            end = str.length;\r\n        }\r\n        this.string = str;\r\n        this.pos = this.start = start || 0;\r\n        this.end = end || 0;\r\n    }\r\n    /**\r\n     * Returns true only if the stream is at the end of the file.\r\n     */\r\n    eof() {\r\n        return this.pos >= this.end;\r\n    }\r\n    /**\r\n     * Creates a new stream instance which is limited to given `start` and `end`\r\n     * range. E.g. its `eof()` method will look at `end` property, not actual\r\n     * stream end\r\n     */\r\n    limit(start, end) {\r\n        return new Scanner(this.string, start, end);\r\n    }\r\n    /**\r\n     * Returns the next character code in the stream without advancing it.\r\n     * Will return NaN at the end of the file.\r\n     */\r\n    peek() {\r\n        return this.string.charCodeAt(this.pos);\r\n    }\r\n    /**\r\n     * Returns the next character in the stream and advances it.\r\n     * Also returns <code>undefined</code> when no more characters are available.\r\n     */\r\n    next() {\r\n        if (this.pos < this.string.length) {\r\n            return this.string.charCodeAt(this.pos++);\r\n        }\r\n    }\r\n    /**\r\n     * `match` can be a character code or a function that takes a character code\r\n     * and returns a boolean. If the next character in the stream 'matches'\r\n     * the given argument, it is consumed and returned.\r\n     * Otherwise, `false` is returned.\r\n     */\r\n    eat(match) {\r\n        const ch = this.peek();\r\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\r\n        if (ok) {\r\n            this.next();\r\n        }\r\n        return ok;\r\n    }\r\n    /**\r\n     * Repeatedly calls <code>eat</code> with the given argument, until it\r\n     * fails. Returns <code>true</code> if any characters were eaten.\r\n     */\r\n    eatWhile(match) {\r\n        const start = this.pos;\r\n        while (!this.eof() && this.eat(match)) { /* */ }\r\n        return this.pos !== start;\r\n    }\r\n    /**\r\n     * Backs up the stream n characters. Backing it up further than the\r\n     * start of the current token will cause things to break, so be careful.\r\n     */\r\n    backUp(n) {\r\n        this.pos -= (n || 1);\r\n    }\r\n    /**\r\n     * Get the string between the start of the current token and the\r\n     * current stream position.\r\n     */\r\n    current() {\r\n        return this.substring(this.start, this.pos);\r\n    }\r\n    /**\r\n     * Returns substring for given range\r\n     */\r\n    substring(start, end) {\r\n        return this.string.slice(start, end);\r\n    }\r\n    /**\r\n     * Creates error object with current stream state\r\n     */\r\n    error(message, pos = this.pos) {\r\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\r\n    }\r\n}\r\nclass ScannerError extends Error {\r\n    constructor(message, pos, str) {\r\n        super(message);\r\n        this.pos = pos;\r\n        this.string = str;\r\n    }\r\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = field(scanner)\n            || numberValue(scanner)\n            || colorValue(scanner)\n            || stringValue(scanner)\n            || bracket(scanner)\n            || operator(scanner)\n            || whiteSpace(scanner)\n            || literal(scanner, brackets === 0 && !isValue)\n            || void 0;\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        scanner.start = scanner.pos;\n        scanner.eat(116 /* Transparent */) || scanner.eatWhile(isHex);\n        const color = scanner.current();\n        let alpha;\n        // a hex color can be followed by `.num` alpha value\n        scanner.start = scanner.pos;\n        if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n            alpha = scanner.current();\n        }\n        const { r, g, b, a } = parseColor(color, alpha);\n        return {\n            type: 'ColorValue',\n            r, g, b, a,\n            raw: scanner.substring(start + 1, scanner.pos),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    if (!options.value && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    consume(scanner, isWhiteSpace);\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token)) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token) || isWhiteSpace(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isWhiteSpace(token)\n        || isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { tokenize };\n","import { AbbreviationAttribute, AbbreviationNode, Value } from '@emmetio/abbreviation';\nimport { Config } from '../config';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nexport default function mergeAttributes(node: AbbreviationNode, config: Config) {\n    if (!node.attributes) {\n        return;\n    }\n\n    const attributes: AbbreviationAttribute[] = [];\n    const lookup: { [name: string]: AbbreviationAttribute } = {};\n\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                } else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            } else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = { ...attr });\n            }\n        } else {\n            attributes.push(attr);\n        }\n    }\n\n    node.attributes = attributes;\n}\n\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev?: Value[], next?: Value[], glue?: string): Value[] | undefined {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n\n        for (const t of next) {\n            append(prev, t);\n        }\n\n        return prev;\n    }\n\n    const result = prev || next;\n    return result && result.slice();\n}\n\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest: AbbreviationAttribute, src: AbbreviationAttribute, config: Config): AbbreviationAttribute {\n    dest.name = src.name;\n\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n\n    return dest;\n}\n\nfunction append(tokens: Value[], value: Value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    } else {\n        tokens.push(value);\n    }\n}\n","import { Abbreviation, AbbreviationNode } from '@emmetio/abbreviation';\n\nexport type Container = Abbreviation | AbbreviationNode;\nexport type WalkVisitor<S> = (node: AbbreviationNode, ancestors: Container[], state?: S) => void;\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nexport function walk<S>(node: Container, fn: WalkVisitor<S>, state?: S) {\n    const ancestors: Container[] = [node];\n    const callback = (ctx: AbbreviationNode) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n\n    node.children.forEach(callback);\n}\n\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nexport function findDeepest(node: Container): { node: Container, parent?: Container } {\n    let parent: Container | undefined;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n\n    return { parent, node };\n}\n\nexport function isNode(node: Container): node is AbbreviationNode {\n    return node.type === 'AbbreviationNode';\n}\n","import parse, { AbbreviationNode, AbbreviationAttribute, Abbreviation } from '@emmetio/abbreviation';\nimport { findDeepest, isNode, Container } from './utils';\nimport { Config } from '../config';\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nexport default function resolveSnippets(abbr: Abbreviation, config: Config): Abbreviation {\n    const stack: string[] = [];\n    const reversed = config.options['output.reverseAttributes'];\n\n    const resolve = (child: AbbreviationNode): Abbreviation | null => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n\n        const snippetAbbr = parse(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            const from: AbbreviationAttribute[] = topNode.attributes || [];\n            const to: AbbreviationAttribute[] = child.attributes || [];\n            topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            mergeNodes(child, topNode);\n        }\n\n        return snippetAbbr;\n    };\n\n    walkResolve(abbr, resolve);\n    return abbr;\n}\n\nfunction walkResolve(node: Container, resolve: (node: AbbreviationNode) => Abbreviation | null): AbbreviationNode[] {\n    let children: AbbreviationNode[] = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        } else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n\n    return node.children = children;\n}\n\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from: AbbreviationNode, to: AbbreviationNode) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n\n    if (from.value != null) {\n        to.value = from.value;\n    }\n\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n","import { AbbreviationAttribute, AbbreviationNode } from '@emmetio/abbreviation';\nimport { Config, Options, StringCase } from './config';\n\nexport interface OutputStream {\n    options: Options;\n    value: string;\n    level: number;\n    offset: number;\n    line: number;\n    column: number;\n}\n\nexport default function createOutputStream(options: Options, level = 0): OutputStream {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n\n/**\n * Pushes plain string into output stream without newline processing\n */\nexport function push(stream: OutputStream, text: string) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n\n/**\n * Pushes given string with possible newline formatting into output\n */\nexport function pushString(stream: OutputStream, value: string) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n\n/**\n * Pushes new line into given output stream\n */\nexport function pushNewline(stream: OutputStream, indent?: boolean | number) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n\n/**\n * Adds indentation of `size` to current output stream\n */\nexport function pushIndent(stream: OutputStream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n\n/**\n * Pushes field/tabstop into output stream\n */\nexport function pushField(stream: OutputStream, index: number, placeholder: string) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n\n/**\n * Returns given tag name formatted according to given config\n */\nexport function tagName(name: string, config: Config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n\n/**\n * Returns given attribute name formatted according to given config\n */\nexport function attrName(name: string, config: Config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n\n/**\n * Returns character for quoting value of given attribute\n */\nexport function attrQuote(attr: AbbreviationAttribute, config: Config, isOpen?: boolean): string {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n\n/**\n * Check if given attribute is boolean\n */\nexport function isBooleanAttribute(attr: AbbreviationAttribute, config: Config): boolean {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nexport function selfClose(config: Config): string {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nexport function isInline(node: string | AbbreviationNode, config: Config): boolean {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n\n/**\n * Splits given text by lines\n */\nexport function splitByLines(text: string): string[] {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream: OutputStream, text: string) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\n\nfunction strCase(str: string, type: StringCase) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n\n    return str;\n}\n","import { AbbreviationNode } from '@emmetio/abbreviation';\nimport { isNode, Container } from './utils';\nimport { Config } from '../config';\nimport { isInline } from '../output-stream';\n\nconst elementMap: { [name: string]: string } = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\n\nexport default function implicitTag(node: AbbreviationNode, ancestors: Container[], config: Config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\n\nexport function resolveImplicitTag(node: AbbreviationNode, ancestors: Container[], config: Config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\n\nfunction lowercase(str?: string): string {\n    return (str || '').toLowerCase();\n}\n\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors: Container[]): AbbreviationNode | undefined {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n","{\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n}\n","{\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n}\n","{\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n}\n","import { AbbreviationNode, Repeater } from '@emmetio/abbreviation';\nimport { Container } from '../utils';\nimport { Config } from '../../config';\nimport { resolveImplicitTag } from '../implicit-tag';\nimport latin from './latin.json';\nimport ru from './russian.json';\nimport sp from './spanish.json';\n\ninterface LoremVocabulary {\n    common: string[];\n    words: string[];\n}\n\nconst vocabularies: { [lang: string]: LoremVocabulary } = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\n\nexport default function lorem(node: AbbreviationNode, ancestors: Container[], config: Config) {\n    let m: RegExpMatchArray | null;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db: LoremVocabulary = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from: number, to: number): number {\n    return Math.floor(Math.random() * (to - from) + from);\n}\n\nfunction sample(arr: string[], count: number): string[] {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result: string[] = [];\n\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n\n    return result;\n}\n\nfunction choice(val: string): string {\n    return val[rand(0, val.length - 1)];\n}\n\nfunction sentence(words: string[], end?: string): string {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\n\nfunction capitalize(word: string): string {\n    return word[0].toUpperCase() + word.slice(1);\n}\n\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words: string[]): string[] {\n    if (words.length < 2) {\n        return words;\n    }\n\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    } else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    } else {\n        totalCommas = rand(1, 4);\n    }\n\n    for (let i = 0, pos: number; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n\n    return words;\n}\n\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict: LoremVocabulary, wordCount: number, startWithCommon: boolean): string {\n    const result: string[] = [];\n    let totalWords = 0;\n    let words: string[];\n\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n\n    return result.join(' ');\n}\n\nfunction findRepeater(ancestors: Container[]): Repeater | void {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n","import { AbbreviationNode, AbbreviationAttribute } from '@emmetio/abbreviation';\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nexport default function jsx(node: AbbreviationNode) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\n\nfunction rename(attr: AbbreviationAttribute) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    } else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n","import { AbbreviationNode, AbbreviationAttribute } from '@emmetio/abbreviation';\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nexport default function xsl(node: AbbreviationNode) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\n\nfunction isAllowed(attr: AbbreviationAttribute): boolean {\n    return attr.name !== 'select';\n}\n\nfunction matchesName(name?: string): boolean {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n","import { AbbreviationNode, Value } from '@emmetio/abbreviation';\nimport { Container } from '../utils';\nimport { Config, AbbreviationContext } from '../../config';\n\ninterface BEMAbbreviationNode extends AbbreviationNode {\n    _bem?: BEMData;\n}\n\ninterface BEMAbbreviationContext extends AbbreviationContext {\n    _bem?: BEMData;\n}\n\ninterface BEMData {\n    classNames: string[];\n    block?: string ;\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className: string) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className: string) => /^[a-z]/i.test(className);\n\nexport default function bem(node: AbbreviationNode, ancestors: Container[], config: Config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node: BEMAbbreviationNode) {\n    const data = getBEMData(node);\n\n    const classNames: string[] = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        } else {\n            classNames.push(cl);\n        }\n    }\n\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node: BEMAbbreviationNode, ancestors: Container[], config: Config) {\n    const data = getBEMData(node);\n    const classNames: string[] = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node) as BEMAbbreviationNode[];\n\n    for (let cl of data.classNames) {\n        let prefix: string = '';\n        let m: RegExpMatchArray | null;\n        const originalClass = cl;\n\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node: BEMAbbreviationNode): BEMData {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n\n        node._bem = parseBEM(classValue);\n    }\n\n    return node._bem;\n}\n\nfunction getBEMDataFromContext(context: BEMAbbreviationContext) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n\n    return context._bem;\n}\n\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue?: string): BEMData {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors: BEMAbbreviationNode[], depth: number = 0, context?: BEMAbbreviationContext): string {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent as BEMAbbreviationNode);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n\n    return '';\n}\n\nfunction findBlockName(classNames: string[]): string | undefined {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames: string[], filter: (className: string) => boolean): string | void {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\n\nfunction updateClass(node: AbbreviationNode, value: string) {\n    for (const attr of node.attributes!) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\n\nfunction stringifyValue(value: Value[]): string {\n    let result = '';\n\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n\n    return result;\n}\n\nfunction uniqueClass<T>(item: T, ix: number, arr: T[]): boolean {\n    return !!item && arr.indexOf(item) === ix;\n}\n","import { AbbreviationNode, Abbreviation } from '@emmetio/abbreviation';\nimport createOutputStream, { OutputStream } from '../../output-stream';\nimport { Config } from '../../config';\n\nexport type WalkNext = (node: AbbreviationNode, index: number, items: AbbreviationNode[]) => void;\nexport type Visitor<S extends WalkState> = (node: AbbreviationNode, index: number, items: AbbreviationNode[], state: S, next: WalkNext) => void;\n\nexport interface WalkState {\n    /** Context node */\n    current: AbbreviationNode;\n\n    /** Immediate parent of currently iterated method */\n    parent?: AbbreviationNode;\n\n    /** List of all ancestors of context node */\n    ancestors: AbbreviationNode[];\n\n    /** Current output config */\n    config: Config;\n\n    /** Output stream */\n    out: OutputStream;\n\n    /** Current field index, used to output field marks for editor tabstops */\n    field: number;\n}\n\nexport default function walk<S extends WalkState>(abbr: Abbreviation, visitor: Visitor<S>, state: S) {\n    const callback = (ctx: AbbreviationNode, index: number, items: AbbreviationNode[]) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n\n    const next: WalkNext = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n\n    abbr.children.forEach(callback);\n}\n\nexport function createWalkState(config: Config): WalkState {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n","import { AbbreviationNode, Field, Value, AbbreviationAttribute } from '@emmetio/abbreviation';\nimport { WalkState } from './walk';\nimport { pushString, pushField, isInline } from '../../output-stream';\nimport { Config } from '../../config';\n\nexport const caret = [{ type: 'Field', index: 0, name: '' } as Field];\n\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nexport function isSnippet(node?: AbbreviationNode): boolean {\n    return node ? !node.name && !node.attributes : false;\n}\n\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nexport function isInlineElement(node: AbbreviationNode | undefined, config: Config): boolean {\n    return node ? isInline(node, config) : false;\n}\n\n/**\n * Check if given value token is a field\n */\nexport function isField(token: Value): token is Field {\n    return typeof token === 'object' && token.type === 'Field';\n}\n\nexport function pushTokens(tokens: Value[], state: WalkState) {\n    const { out } = state;\n    let largestIndex = -1;\n\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        } else {\n            pushField(out, state.field + t.index!, t.name);\n            if (t.index! > largestIndex) {\n                largestIndex = t.index!;\n            }\n        }\n    }\n\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nexport function splitByLines(tokens: Value[]): Value[][] {\n    const result: Value[][] = [];\n    let line: Value[] = [];\n\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        } else {\n            line.push(t);\n        }\n    }\n\n    line.length && result.push(line);\n    return result;\n}\n\n/**\n * Check if given attribute should be outputted\n */\nexport function shouldOutputAttribute(attr: AbbreviationAttribute): boolean {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n","export type TemplateToken = string | TemplatePlaceholder;\nexport interface TemplatePlaceholder {\n    before: string;\n    after: string;\n    name: string;\n}\n\ninterface TokenScanner {\n    text: string;\n    pos: number;\n}\n\nconst enum TemplateChars {\n    /** `[` character */\n    Start = 91,\n\n    /** `]` character */\n    End = 93,\n\n    /* `_` character */\n    Underscore = 95,\n\n    /* `-` character */\n    Dash = 45,\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nexport default function template(text: string): TemplateToken[] {\n    const tokens: TemplateToken[] = [];\n    const scanner: TokenScanner = { pos: 0, text };\n    let placeholder: TemplatePlaceholder | undefined;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        } else {\n            scanner.pos++;\n        }\n    }\n\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n\n    return tokens;\n}\n\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner: TokenScanner): TemplatePlaceholder | undefined {\n    if (peek(scanner) === TemplateChars.Start) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            } else {\n                if (code === TemplateChars.Start) {\n                    stack++;\n                } else if (code === TemplateChars.End) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n\n                scanner.pos++;\n            }\n        }\n    }\n}\n\nfunction peek(scanner: TokenScanner, pos = scanner.pos): number {\n    return scanner.text.charCodeAt(pos);\n}\n\nfunction isTokenStart(code: number): boolean {\n    return code >= 65 && code <= 90; // A-Z\n}\n\nfunction isToken(code: number): boolean {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === TemplateChars.Underscore\n        || code === TemplateChars.Dash;\n}\n","import { AbbreviationNode, Value } from '@emmetio/abbreviation';\nimport { pushString } from '../../output-stream';\nimport { WalkState } from './walk';\nimport { pushTokens } from './utils';\nimport template, { TemplateToken } from './template';\nimport { Config } from '../../config';\nimport { HTMLWalkState } from './html';\n\nexport interface CommentWalkState {\n    enabled: boolean;\n    trigger: string[];\n    before?: TemplateToken[];\n    after?: TemplateToken[];\n}\n\nexport function createCommentState(config: Config): CommentWalkState {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n\n/**\n * Adds comment prefix for given node, if required\n */\nexport function commentNodeBefore(node: AbbreviationNode, state: HTMLWalkState) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n\n/**\n * Adds comment suffix for given node, if required\n */\nexport function commentNodeAfter(node: AbbreviationNode, state: HTMLWalkState) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node: AbbreviationNode, state: HTMLWalkState): boolean {\n    const { comment } = state;\n\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node: AbbreviationNode, tokens: TemplateToken[], state: WalkState) {\n    const attrs: { [name: string]: Value[] } = {};\n    const { out } = state;\n\n    // Collect attributes payload\n    for (const attr of node.attributes!) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        } else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n","import { Abbreviation, AbbreviationNode, AbbreviationAttribute, Value } from '@emmetio/abbreviation';\nimport { pushNewline, pushString, tagName, selfClose, attrName, isBooleanAttribute, attrQuote, isInline } from '../../output-stream';\nimport walk, { WalkState, createWalkState } from './walk';\nimport { caret, isInlineElement, isSnippet, isField, pushTokens, shouldOutputAttribute } from './utils';\nimport { commentNodeBefore, commentNodeAfter, CommentWalkState, createCommentState } from './comment';\nimport { Config } from '../../config';\n\ntype WalkNext = (node: AbbreviationNode, index: number, items: AbbreviationNode[]) => void;\n\nexport interface HTMLWalkState extends WalkState {\n    comment: CommentWalkState;\n}\n\nexport default function html(abbr: Abbreviation, config: Config): string {\n    const state = createWalkState(config) as HTMLWalkState;\n    state.comment = createCommentState(config);\n    walk(abbr, element, state);\n    return state.out.value;\n}\n\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node: AbbreviationNode, index: number, items: AbbreviationNode[], state: HTMLWalkState, next: WalkNext) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n\n    format && pushNewline(out, true);\n\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        } else {\n            pushString(out, '>');\n\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n\n                node.children.forEach(next);\n\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    } else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n\n    out.level -= level;\n}\n\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr: AbbreviationAttribute, state: WalkState) {\n    const { out, config } = state;\n\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        } else if (!value) {\n            value = caret;\n        }\n\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        } else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\n\nexport function pushSnippet(node: AbbreviationNode, state: WalkState, next: WalkNext): boolean {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, (node.value[pos++] as string).trimLeft());\n            }\n\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node: AbbreviationNode, index: number, items: AbbreviationNode[], state: WalkState): boolean {\n    const { config, parent } = state;\n\n    if (!config.options['output.format']) {\n        return false;\n    }\n\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n\n            // Has newlines: looks like wrapping code fragment\n            || node.value!.some(hasNewline)\n\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value!.some(isField) && node.children.length);\n\n        if (format) {\n            return true;\n        }\n    }\n\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        } else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state: WalkState): number {\n    const { config, parent } = state;\n\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n\n    return 1;\n}\n\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value: Value): boolean {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n","import { AbbreviationNode, AbbreviationAttribute, Value, Abbreviation } from '@emmetio/abbreviation';\nimport { pushString, pushNewline, push, attrName, isBooleanAttribute, attrQuote } from '../../output-stream';\nimport { pushTokens, caret, splitByLines, isSnippet, shouldOutputAttribute } from './utils';\nimport walk, { WalkState, createWalkState, WalkNext } from './walk';\nimport { Config } from '../../config';\n\n/**\n * @description Utility methods for working with indent-based markup languages\n * like HAML, Slim, Pug etc.\n */\n\ninterface AttributesCollection {\n    /** Primary element attributes: `id` and `class` */\n    primary: AbbreviationAttribute[];\n\n    /** Secondary element attributes: everything except `id` and `class` */\n    secondary: AbbreviationAttribute[];\n}\n\nexport interface IndentWalkState extends WalkState {\n    options: FormatOptions;\n}\n\nexport interface FormatOptions {\n    /** String to output before tag name */\n    beforeName?: string;\n\n    /** String to output after tag name */\n    afterName?: string;\n\n    /** String to output before secondary attribute set */\n    beforeAttribute?: string;\n\n    /** String to output after secondary attribute set */\n    afterAttribute?: string;\n\n    /** String to put between secondary attributes */\n    glueAttribute?: string;\n\n    /** Value for boolean attributes */\n    booleanValue?: string;\n\n    /** String to put before content line (if value is multiline) */\n    beforeTextLine?: string;\n\n    /** String to put after content line (if value is multiline) */\n    afterTextLine?: string;\n}\n\nexport default function indentFormat(abbr: Abbreviation, config: Config, options?: Partial<FormatOptions>): string {\n    const state = createWalkState(config) as IndentWalkState;\n    state.options = options || {};\n    walk(abbr, element, state);\n    return state.out.value;\n}\n\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nexport function element(node: AbbreviationNode, index: number, items: AbbreviationNode[], state: IndentWalkState, next: WalkNext) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n\n    // Do not indent top-level elements\n    if (shouldFormat(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n\n    if (node.selfClosing && !node.value && !node.children.length) {\n        pushString(out, '/');\n    } else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n\n    out.level -= level;\n}\n\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nexport function collectAttributes(node: AbbreviationNode): AttributesCollection {\n    const primary: AbbreviationAttribute[] = [];\n    const secondary: AbbreviationAttribute[] = [];\n\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            } else {\n                secondary.push(attr);\n            }\n        }\n    }\n\n    return { primary, secondary };\n}\n\n/**\n * Outputs given attributes as primary into output stream\n */\nexport function pushPrimaryAttributes(attrs: AbbreviationAttribute[], state: WalkState) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            } else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n\n/**\n * Outputs given attributes as secondary into output stream\n */\nexport function pushSecondaryAttributes(attrs: AbbreviationAttribute[], state: IndentWalkState) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            } else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n\n/**\n * Outputs given node value into state output stream\n */\nexport function pushValue(node: AbbreviationNode, state: IndentWalkState) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n\n    const value = node.value || caret;\n    const lines = splitByLines(value);\n    const { out, options } = state;\n\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    } else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths: number[] = [];\n        let maxLength = 0;\n\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\n\nfunction isPrimaryAttribute(attr: AbbreviationAttribute): boolean {\n    return attr.name === 'class' || attr.name === 'id';\n}\n\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens: Value[]): number {\n    let len = 0;\n\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n\n    return len;\n}\n\nfunction shouldFormat(node: AbbreviationNode, index: number, items: AbbreviationNode[], state: WalkState): boolean {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n","import { Abbreviation } from '@emmetio/abbreviation';\nimport indentFormat from './indent-format';\nimport { Config } from '../../config';\n\nexport default function haml(abbr: Abbreviation, config: Config): string {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true'\n    });\n}\n","import { Abbreviation } from '@emmetio/abbreviation';\nimport indentFormat from './indent-format';\nimport { Config } from '../../config';\n\nexport default function slim(abbr: Abbreviation, config: Config): string {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| '\n    });\n}\n","import { Abbreviation } from '@emmetio/abbreviation';\nimport indentFormat from './indent-format';\nimport { Config } from '../../config';\n\nexport default function pug(abbr: Abbreviation, config: Config): string {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| '\n    });\n}\n","import abbreviation, { Abbreviation, AbbreviationNode, ParserOptions } from '@emmetio/abbreviation';\nimport attributes from './attributes';\nimport snippets from './snippets';\nimport implicitTag from './implicit-tag';\nimport lorem from './lorem';\nimport jsx from './addon/jsx';\nimport xsl from './addon/xsl';\nimport bem from './addon/bem';\nimport html from './format/html';\nimport haml from './format/haml';\nimport slim from './format/slim';\nimport pug from './format/pug';\nimport { Config } from '../config';\nimport { walk, Container } from './utils';\n\ntype Formatter = (abbr: Abbreviation, config: Config) => string;\n\nconst formatters: { [syntax: string]: Formatter } = { html, haml, slim, pug };\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nexport default function parse(abbr: string | Abbreviation, config: Config): Abbreviation {\n    if (typeof abbr === 'string') {\n        let parseOpt: ParserOptions = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = {\n                ...parseOpt,\n                jsx: true\n            };\n        }\n\n        abbr = abbreviation(abbr, parseOpt);\n    }\n\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = snippets(abbr, config);\n    walk(abbr, transform, config);\n    return abbr;\n}\n\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nexport function stringify(abbr: Abbreviation, config: Config): string {\n    const formatter: Formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node: AbbreviationNode, ancestors: Container[], config: Config) {\n    implicitTag(node, ancestors, config);\n    attributes(node, config);\n    lorem(node, ancestors, config);\n\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n","import parse, { CSSValue, ParseOptions, FunctionCall, Literal } from '@emmetio/css-abbreviation';\n\nexport type CSSSnippet = CSSSnippetRaw | CSSSnippetProperty;\n\ninterface KeywordMap {\n    [name: string]: FunctionCall | Literal;\n}\n\nexport const enum CSSSnippetType {\n    Raw = 'Raw',\n    Property = 'Property'\n}\n\ninterface CSSSnippetBase {\n    type: CSSSnippetType;\n    key: string;\n}\n\nexport interface CSSSnippetRaw extends CSSSnippetBase {\n    type: CSSSnippetType.Raw;\n    value: string;\n}\n\nexport interface CSSSnippetProperty extends CSSSnippetBase {\n    type: CSSSnippetType.Property;\n    property: string;\n    value: CSSValue[][];\n    keywords: KeywordMap;\n    dependencies: CSSSnippetProperty[];\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt: ParseOptions = { value: true };\n\n/**\n * Creates structure for holding resolved CSS snippet\n */\nexport default function createSnippet(key: string, value: string): CSSSnippet {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords: KeywordMap = {};\n        const parsed: CSSValue[][] = m[2] ? m[2].split('|').map(parseValue) : [];\n\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n\n        return {\n            type: CSSSnippetType.Property,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n\n    return { type: CSSSnippetType.Raw, key, value };\n}\n\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nexport function nest(snippets: CSSSnippet[]): CSSSnippet[] {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack: CSSSnippetProperty[] = [];\n    let prev: CSSSnippet;\n\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n\n            if (cur.property.startsWith(prev.property!)\n                && cur.property.charCodeAt(prev.property!.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n\n            stack.pop();\n        }\n\n        if (!stack.length) {\n            stack.push(cur);\n        }\n\n    }\n\n    return snippets;\n}\n\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a: CSSSnippet, b: CSSSnippet): number {\n    if (a.key === b.key) {\n        return 0;\n    }\n\n    return a.key < b.key ? -1 : 1;\n}\n\nfunction parseValue(value: string): CSSValue[] {\n    return parse(value.trim(), opt)[0].value;\n}\n\nfunction isProperty(snippet: CSSSnippet): snippet is CSSSnippetProperty {\n    return snippet.type === CSSSnippetType.Property;\n}\n\nfunction collectKeywords(cssVal: CSSValue, dest: KeywordMap) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        } else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        } else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n","/**\n * Calculates fuzzy match score of how close `abbr` matches given `string`.\n * @param abbr Abbreviation to score\n * @param str String to match\n * @return Match score\n */\nexport default function calculateScore(abbr: string, str: string): number {\n    abbr = abbr.toLowerCase();\n    str = str.toLowerCase();\n\n    if (abbr === str) {\n        return 1;\n    }\n\n    // a string MUST start with the same character as abbreviation\n    if (!str || abbr.charCodeAt(0) !== str.charCodeAt(0)) {\n        return 0;\n    }\n\n    const abbrLength = abbr.length;\n    const stringLength = str.length;\n    let i = 1;\n    let j = 1;\n    let score = stringLength;\n    let ch1: number;\n    let ch2: number;\n    let found: boolean;\n    let acronym: boolean;\n\n    while (i < abbrLength) {\n        ch1 = abbr.charCodeAt(i);\n        found = false;\n        acronym = false;\n\n        while (j < stringLength) {\n            ch2 = str.charCodeAt(j);\n\n            if (ch1 === ch2) {\n                found = true;\n                score += (stringLength - j) * (acronym ? 2 : 1);\n                break;\n            }\n\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n\n        if (!found) {\n            break;\n        }\n\n        i++;\n    }\n\n    return score && score * (i / abbrLength) / sum(stringLength);\n}\n\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n: number): number {\n    return n * (n + 1) / 2;\n}\n","import { ColorValue } from '@emmetio/css-abbreviation';\n\nexport default function color(token: ColorValue, shortHex?: boolean): string {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    } else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n\n    return asRGB(token);\n}\n\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nexport function asHex(token: ColorValue, short?: boolean): string {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token: ColorValue): string {\n    const values: Array<string | number> = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\n\nexport function frac(num: number, digits = 4): string {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\n\nfunction isShortHex(hex: number): boolean {\n    return !(hex % 17);\n}\n\nfunction toShortHex(num: number): string {\n    return (num >> 4).toString(16);\n}\n\nfunction toHex(num: number): string {\n    return pad(num.toString(16), 2);\n}\n\nfunction pad(value: string, len: number): string {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n","import { CSSAbbreviation, CSSProperty, Value, CSSValue, NumberValue } from '@emmetio/css-abbreviation';\nimport createOutputStream, { OutputStream, push, pushString, pushField, pushNewline } from '../output-stream';\nimport { Config } from '../config';\nimport color, { frac } from './color';\n\nexport default function css(abbr: CSSAbbreviation, config: Config): string {\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n\n    return out.value;\n}\n\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node: CSSProperty, out: OutputStream, config: Config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        } else {\n            pushField(out, 0, '');\n        }\n\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        } else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    } else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\n\nfunction propertyValue(node: CSSProperty, out: OutputStream, config: Config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    } else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\n\nfunction outputImportant(node: CSSProperty, out: OutputStream, separator?: boolean) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\n\nfunction outputValue(value: CSSValue, out: OutputStream, config: Config) {\n    for (let i = 0; i < value.value.length; i++) {\n        const token = value.value[i];\n        if (i !== 0) {\n            push(out, ' ');\n        }\n\n        outputToken(token, out, config);\n    }\n}\n\nfunction outputToken(token: Value, out: OutputStream, config: Config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    } else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    } else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    } else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    } else if (token.type === 'Field') {\n        pushField(out, token.index!, token.name);\n    } else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node: CSSProperty): NumberValue | void {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0]!;\n        if (cssVal.value.length === 1 && cssVal.value[0]!.type === 'NumberValue') {\n            return cssVal.value[0] as NumberValue;\n        }\n    }\n}\n\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str: string): string {\n    return str.replace(/\\-(\\w)/g, (_, letter: string) => letter.toUpperCase());\n}\n\nfunction getQuote(config: Config): string {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n","import abbreviation, { CSSAbbreviation, CSSProperty, CSSValue, Literal, Value, Field, FunctionCall } from '@emmetio/css-abbreviation';\nimport { Config, SnippetsMap } from '../config';\nimport createSnippet, { CSSSnippet, nest, CSSSnippetType, CSSSnippetRaw, CSSSnippetProperty } from './snippets';\nimport calculateScore from './score';\nimport color from './color';\n\ntype MatchInput = CSSSnippet | string;\nconst gradientName = 'lg';\n\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nexport default function parse(abbr: string | CSSAbbreviation, config: Config, snippets = convertSnippets(config.snippets)): CSSAbbreviation {\n    if (typeof abbr === 'string') {\n        abbr = abbreviation(abbr, { value: !!config.context });\n    }\n\n    for (const node of abbr) {\n        resolveNode(node, snippets, config);\n    }\n\n    return abbr;\n}\n\nexport { default as stringify } from './format';\n\n/**\n * Converts given raw snippets into internal snippets representation\n */\nexport function convertSnippets(snippets: SnippetsMap): CSSSnippet[] {\n    const result: CSSSnippet[] = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n\n    return nest(result);\n}\n\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node: CSSProperty, snippets: CSSSnippet[], config: Config): CSSProperty {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (config.context) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === CSSSnippetType.Property && s.property === propName) as CSSSnippetProperty | undefined;\n            resolveValueKeywords(node, config, snippet, score);\n        } else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score);\n\n            if (snippet) {\n                if (snippet.type === CSSSnippetType.Property) {\n                    resolveAsProperty(node, snippet, config);\n                } else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n\n    return node;\n}\n\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node: CSSProperty, config: Config): boolean {\n    let gradientFn: FunctionCall | null = null;\n    const cssVal = node.value.length === 1 ? node.value[0]! : null;\n\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0]!;\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        } else {\n            gradientFn = {\n                ...gradientFn,\n                name: 'linear-gradient'\n            };\n        }\n\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node: CSSProperty, snippet: CSSSnippetProperty, config: Config): CSSProperty {\n    const abbr = node.name!;\n    node.name = snippet.property;\n\n    if (!node.value.length) {\n        // No value defined in abbreviation node, try to resolve unmatched part\n        // as a keyword alias\n        const inlineValue = getUnmatchedPart(abbr, snippet.key);\n        const kw = inlineValue ? resolveKeyword(inlineValue, config, snippet) : null;\n        if (kw) {\n            node.value.push(cssValue(kw));\n        } else if (snippet.value.length) {\n            const defaultValue = snippet.value[0]!;\n\n            // https://github.com/emmetio/emmet/issues/558\n            // We should auto-select inserted value only if there’s multiple value\n            // choice\n            node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n                ? defaultValue\n                : defaultValue.map(n => wrapWithField(n, config));\n        }\n    } else {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n\n    return node;\n}\n\nfunction resolveValueKeywords(node: CSSProperty, config: Config, snippet?: CSSSnippetProperty, minScore?: number) {\n    for (const cssVal of node.value) {\n        const value: Value[] = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            } else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push({\n                        ...match,\n                        arguments: token.arguments.concat(match.arguments.slice(token.arguments.length))\n                    });\n                } else {\n                    value.push(token);\n                }\n            } else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node: CSSProperty, snippet: CSSSnippetRaw): CSSProperty {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m: RegExpExecArray | null;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue: Value[] = [];\n\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift()!);\n        } else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nexport function findBestMatch<T extends MatchInput>(abbr: string, items: T[], minScore = 0): T | null {\n    let matchedItem: T | null = null;\n    let maxScore = 0;\n\n    for (const item of items) {\n        const score = calculateScore(abbr, getScoringPart(item));\n\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n\n    return maxScore >= minScore ? matchedItem : null;\n}\n\nfunction getScoringPart(item: MatchInput): string {\n    return typeof item === 'string' ? item : item.key;\n}\n\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr: string, str: string): string {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n\n    return '';\n}\n\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw: string, config: Config, snippet?: CSSSnippetProperty, minScore?: number): Literal | FunctionCall | null {\n    let ref: string | null;\n\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n\n    return null;\n}\n\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node: CSSProperty, config: Config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                } else if (t.value !== 0 && !unitless.includes(node.name!)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args: Value[]): CSSValue {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n\n/**\n * Constructs literal token\n */\nfunction literal(value: string): Literal {\n    return { type: 'Literal', value };\n}\n\n/**\n * Constructs field token\n */\nfunction field(index: number, name: string): Field {\n    return { type: 'Field', index, name };\n}\n\n/**\n * Check if given value contains fields\n */\nfunction hasField(value: CSSValue): boolean {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\ninterface WrapState {\n    index: number;\n}\n\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node: CSSValue, config: Config, state: WrapState = { index: 1 }): CSSValue {\n    let value: Value[] = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n\n    return {...node, value };\n}\n","{\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n}\n","{\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${1});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:grid|inline-grid|subgrid|block|none|flex|inline-flex|inline|inline-block|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat()|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat()|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n}\n","{\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n}","{\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n}\n","import markupSnippets from '../snippets/html.json';\nimport stylesheetSnippets from '../snippets/css.json';\nimport xslSnippets from '../snippets/xsl.json';\nimport variables from '../snippets/variables.json';\n\nexport type SyntaxType = 'markup' | 'stylesheet';\nexport type FieldOutput = (index: number, placeholder: string, offset: number, line: number, column: number) => string;\nexport type TextOutput = (text: string, offset: number, line: number, column: number) => string;\nexport type StringCase = '' | 'lower' | 'upper';\nexport interface SnippetsMap {\n    [name: string]: string;\n}\n\nexport interface AbbreviationContext {\n    name: string;\n    attributes?: { [name: string]: string | null };\n}\n\n/**\n * Raw config which contains per-syntax options. `markup` and `syntax` keys are\n * reserved for global settings for all markup and stylesheet syntaxes\n */\nexport interface GlobalConfig {\n    [syntax: string]: Partial<BaseConfig>;\n}\n\nexport interface BaseConfig {\n    /* Type of abbreviation context, default is `markup` */\n    type: SyntaxType;\n\n    /** Options for abbreviation output */\n    options: Partial<Options>;\n\n    /** Substitutions for variable names */\n    variables: SnippetsMap;\n\n    /** Abbreviation name to snippets mapping */\n    snippets: SnippetsMap;\n}\n\ninterface ResolvedConfig extends BaseConfig {\n    /** Host syntax */\n    syntax: string;\n\n    /**\n     * Context of abbreviation. For markup abbreviation, it contains parent tag\n     * name with attributes, for stylesheet abbreviation it contains property name\n     * if abbreviation is expanded as value\n     */\n    context?: AbbreviationContext;\n\n    /** Text to wrap with abbreviation */\n    text?: string | string[];\n\n    /** Max amount of repeated elements (fool proof) */\n    maxRepeat?: number;\n}\n\nexport type Config = ResolvedConfig & { options: Options };\nexport type UserConfig = Partial<ResolvedConfig>;\n\nexport interface Options {\n    /////////////////////\n    // Generic options //\n    /////////////////////\n\n    /** A list of inline-level elements */\n    inlineElements: string[];\n\n    ////////////////////\n    // Output options //\n    ////////////////////\n\n    /** A string for one level indent */\n    'output.indent': string;\n\n    /**\n     * A string for base indent, e.g. context indentation which will be added\n     * for every generated line\n     */\n    'output.baseIndent': string;\n\n    /** A string to use as a new line */\n    'output.newline': string;\n\n    /** Tag case: lower, upper or '' (keep as-is) */\n    'output.tagCase': StringCase;\n\n    /** Attribute name case: lower, upper or '' (keep as-is) */\n    'output.attributeCase': StringCase;\n\n    /** Attribute value quotes: 'single' or 'double' */\n    'output.attributeQuotes': 'single' | 'double';\n\n    /** Enable output formatting (indentation and line breaks) */\n    'output.format': boolean;\n\n    /** When enabled, automatically adds inner line breaks for leaf (e.g. without children) nodes */\n    'output.formatLeafNode': boolean;\n\n    /** A list of tag names that should not get inner indentation */\n    'output.formatSkip': string[];\n\n    /** A list of tag names that should *always* get inner indentation. */\n    'output.formatForce': string[];\n\n    /**\n     * How many inline sibling elements should force line break for each tag.\n     * Set to `0` to output all inline elements without formatting.\n     * Set to `1` to output all inline elements with formatting (same as block-level).\n     */\n    'output.inlineBreak': number;\n\n    /**\n     * Produce compact notation of boolean attributes: attributes which doesn’t have value.\n     * With this option enabled, outputs `<div contenteditable>` instead of\n     * `<div contenteditable=\"contenteditable\">`\n     */\n    'output.compactBoolean': boolean;\n\n    /** A list of boolean attributes */\n    'output.booleanAttributes': string[];\n\n    /** Reverses attribute merging directions when resolving snippets */\n    'output.reverseAttributes': boolean;\n\n    /** Style of self-closing tags: html (`<br>`), xml (`<br/>`) or xhtml (`<br />`) */\n    'output.selfClosingStyle': 'html' | 'xml' | 'xhtml';\n\n    /**\n     * A function that takes field index and optional placeholder and returns\n     * a string field (tabstop) for host editor. For example, a TextMate-style\n     * field is `$index` or `${index:placeholder}`\n     * @param index Field index\n     * @param placeholder Field placeholder (default value), if any\n     * @param offset Current character offset from the beginning of generated content\n     * @param line Current line of generated output\n     * @param column Current column in line\n     */\n    'output.field': FieldOutput;\n\n    /**\n     * A function for processing text chunk passed to `OutputStream`.\n     * May be used by editor for escaping characters, if necessary\n     */\n    'output.text': TextOutput;\n\n    ////////////////////////////////\n    // Element commenting options //\n    ////////////////////////////////\n\n    /**\n     * Enable/disable element commenting: generate comments before open and/or\n     * after close tag\n     */\n    'comment.enabled': boolean;\n\n    /**\n     * Attributes that should trigger node commenting on specific node,\n     * if commenting is enabled\n     */\n    'comment.trigger': string[];\n\n    /**\n     * Template string for comment to be placed *before* opening tag\n     */\n    'comment.before': string;\n\n    /**\n     * Template string for comment to be placed *after* closing tag.\n     * Example: `\\n<!-- /[#ID][.CLASS] -->`\n     */\n    'comment.after': string;\n\n    /////////////////\n    // BEM options //\n    /////////////////\n\n    /** Enable/disable BEM addon */\n    'bem.enabled': boolean;\n\n    /** A string for separating elements in output class */\n    'bem.element': string;\n\n    /** A string for separating modifiers in output class */\n    'bem.modifier': string;\n\n    /////////////////\n    // JSX options //\n    /////////////////\n\n    /** Enable/disable JSX addon */\n    'jsx.enabled': boolean;\n\n    ////////////////////////\n    // Stylesheet options //\n    ////////////////////////\n\n    /** List of globally available keywords for properties */\n    'stylesheet.keywords': string[];\n\n    /**\n     * List of unitless properties, e.g. properties where numeric values without\n     * explicit unit will be outputted as is, without default value\n     */\n    'stylesheet.unitless': string[];\n\n    /** Use short hex notation where possible, e.g. `#000` instead of `#000000` */\n    'stylesheet.shortHex': boolean;\n\n    /** A string between property name and value */\n    'stylesheet.between': string;\n\n    /** A string after property value */\n    'stylesheet.after': string;\n\n    /** A unit suffix to output by default after integer values, 'px' by default */\n    'stylesheet.intUnit': string;\n\n    /** A unit suffix to output by default after float values, 'em' by default */\n    'stylesheet.floatUnit': string;\n\n    /**\n     * Aliases for custom units in abbreviation. For example, `r: 'rem'` will\n     * output `10rem` for abbreviation `10r`\n     */\n    'stylesheet.unitAliases': SnippetsMap;\n\n    /** Output abbreviation as JSON object properties (for CSS-in-JS syntaxes) */\n    'stylesheet.json': boolean;\n\n    /** Use double quotes for JSON values */\n    'stylesheet.jsonDoubleQuotes': boolean;\n\n    /**\n     * A float number between 0 and 1 to pick fuzzy-matched abbreviations.\n     * Lower value will pick more abbreviations (and less accurate)\n     */\n    'stylesheet.fuzzySearchMinScore': number;\n}\n\n/**\n * Default syntaxes for abbreviation types\n */\nexport const defaultSyntaxes: { [name in SyntaxType]: string } = {\n    markup: 'html',\n    stylesheet: 'css'\n};\n\n/**\n * List of all known syntaxes\n */\nexport const syntaxes = {\n    markup: ['html', 'xml', 'xsl', 'jsx', 'js', 'pug', 'slim', 'haml'],\n    stylesheet: ['css', 'sass', 'scss', 'less', 'sss', 'stylus']\n};\n\nexport const defaultOptions: Options = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n\n    'jsx.enabled': false,\n\n    'stylesheet.keywords': ['auto', 'inherit', 'unset'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0.3\n};\n\nexport const defaultConfig: Config = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n\n/**\n * Default per-syntax config\n */\nexport const syntaxConfig: GlobalConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nexport function parseSnippets(snippets: SnippetsMap): SnippetsMap {\n    const result: SnippetsMap = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n\n    return result;\n}\n\nexport default function resolveConfig(config: UserConfig = {}, globals: GlobalConfig = {}): Config {\n    const type: SyntaxType = config.type || 'markup';\n    const syntax: string = config.syntax || defaultSyntaxes[type];\n\n    return {\n        ...defaultConfig,\n        ...config,\n        type,\n        syntax,\n        variables: mergedData(type, syntax, 'variables', config, globals),\n        snippets: mergedData(type, syntax, 'snippets', config, globals),\n        options: mergedData(type, syntax, 'options', config, globals)\n    };\n}\n\nfunction mergedData<K extends keyof BaseConfig>(type: SyntaxType, syntax: string, key: K, config: UserConfig, globals: GlobalConfig = {}): Config[K] {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n\n    return {\n        ...(defaultConfig[key] as object),\n        ...(typeDefaults && typeDefaults[key] as object),\n        ...(syntaxDefaults && syntaxDefaults[key] as object),\n        ...(typeOverride && typeOverride[key] as object),\n        ...(syntaxOverride && syntaxOverride[key] as object),\n        ...(config[key] as object)\n    } as Config[K];\n}\n","type Match = ((code: number) => boolean) | number;\n\nexport interface BackwardScanner {\n    /** Text to scan */\n    text: string;\n\n    /** Left bound till given text must be scanned */\n    start: number;\n\n    /** Current scanner position */\n    pos: number;\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nexport default function backwardScanner(text: string, start = 0): BackwardScanner {\n    return { text, start, pos: text.length };\n}\n\n/**\n * Check if given scanner position is at start of scanned text\n */\nexport function sol(scanner: BackwardScanner) {\n    return scanner.pos === scanner.start;\n}\n\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nexport function peek(scanner: BackwardScanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n\n/**\n * Returns current character code and moves character location one symbol back\n */\nexport function previous(scanner: BackwardScanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nexport function consume(scanner: BackwardScanner, match: Match): boolean {\n    if (sol(scanner)) {\n        return false;\n    }\n\n    const ok = typeof match === 'function'\n        ? match(peek(scanner))\n        : match === peek(scanner);\n\n    if (ok) {\n        scanner.pos--;\n    }\n\n    return !!ok;\n}\n\nexport function consumeWhile(scanner: BackwardScanner, match: Match): boolean {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n","import { BackwardScanner, previous, sol, peek } from './reader';\n\nconst enum Chars {\n    SingleQuote = 39,\n    DoubleQuote = 34,\n    Escape = 92\n}\n\n/**\n * Check if given character code is a quote\n */\nexport function isQuote(c?: number) {\n    return c === Chars.SingleQuote || c === Chars.DoubleQuote;\n}\n\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nexport function consumeQuoted(scanner: BackwardScanner): boolean {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek(scanner) !== Chars.Escape) {\n                return true;\n            }\n        }\n    }\n\n    scanner.pos = start;\n    return false;\n}\n","import { isQuote, consumeQuoted } from './quotes';\nimport { BackwardScanner, consume, sol, consumeWhile } from './reader';\n\nconst enum Chars {\n    Tab = 9,\n    Space = 32,\n    /** `-` character */\n    Dash = 45,\n    /** `/` character */\n    Slash = 47,\n    /** `:` character */\n    Colon = 58,\n    /** `=` character */\n    Equals = 61,\n    /** `<` character */\n    AngleLeft = 60,\n    /** `>` character */\n    AngleRight = 62,\n}\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nexport default function isHtml(scanner: BackwardScanner): boolean {\n    const start = scanner.pos;\n\n    if (!consume(scanner, Chars.AngleRight)) {\n        return false;\n    }\n\n    let ok = false;\n    consume(scanner, Chars.Slash); // possibly self-closed element\n\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, Chars.Slash)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, Chars.AngleLeft);\n                break;\n            } else if (consume(scanner, Chars.AngleLeft)) {\n                // opening tag\n                ok = true;\n                break;\n            } else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            } else if (consume(scanner, Chars.Equals)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            } else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n\n            // invalid tag\n            break;\n        }\n\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n\n        break;\n    }\n\n    scanner.pos = start;\n    return ok;\n}\n\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner: BackwardScanner): boolean {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\n\nfunction consumeAttributeWithQuotedValue(scanner: BackwardScanner): boolean {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\nfunction consumeAttributeWithUnquotedValue(scanner: BackwardScanner): boolean {\n    const start = scanner.pos;\n    if (consumeWhile(scanner, isUnquotedValue) && consume(scanner, Chars.Equals) && consumeIdent(scanner)) {\n        return true;\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner: BackwardScanner): boolean {\n    return consumeWhile(scanner, isIdent);\n}\n\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch: number): boolean {\n    return ch === Chars.Colon || ch === Chars.Dash || isAlpha(ch) || isNumber(ch);\n}\n\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch: number): boolean {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch: number): boolean {\n    return ch > 47 && ch < 58;\n}\n\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch: number): boolean {\n    return ch === Chars.Space || ch === Chars.Tab;\n}\n\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch: number): boolean {\n    return !isNaN(ch) && ch !== Chars.Equals && !isWhiteSpace(ch) && !isQuote(ch);\n}\n","import { SyntaxType } from '../config';\nimport backwardScanner, { sol, peek, BackwardScanner, consume } from './reader';\nimport isAtHTMLTag from './is-html';\nimport { isQuote } from './quotes';\n\nexport interface ExtractOptions {\n    /**\n     * Allow parser to look ahead of `pos` index for searching of missing\n     * abbreviation parts. Most editors automatically inserts closing braces for\n     * `[`, `{` and `(`, which will most likely be right after current caret position.\n     * So in order to properly expand abbreviation, user must explicitly move\n     * caret right after auto-inserted braces. With this option enabled, parser\n     * will search for closing braces right after `pos`. Default is `true`\n     */\n    lookAhead: boolean;\n\n    /**\n     * Type of context syntax of expanded abbreviation.\n     * In 'stylesheet' syntax, brackets `[]` and `{}` are not supported thus\n     * not extracted.\n     */\n    type: SyntaxType;\n\n    /**\n     * A string that should precede abbreviation in order to make it successfully\n     * extracted. If given, the abbreviation will be extracted from the nearest\n     * `prefix` occurrence.\n     */\n    prefix: string;\n}\n\nexport interface ExtractedAbbreviation {\n    /** Extracted abbreviation */\n    abbreviation: string;\n\n    /** Location of abbreviation in input string */\n    location: number;\n\n    /** Start location of matched abbreviation, including prefix */\n    start: number;\n\n    /** End location of extracted abbreviation */\n    end: number;\n}\n\nconst enum Brackets {\n    SquareL = 91,\n    SquareR = 93,\n    RoundL = 40,\n    RoundR = 41,\n    CurlyL = 123,\n    CurlyR = 125,\n}\n\nconst code = (ch: string) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst bracePairs = {\n    [Brackets.SquareL]: Brackets.SquareR,\n    [Brackets.RoundL]: Brackets.RoundR,\n    [Brackets.CurlyL]: Brackets.CurlyR,\n};\n\nconst defaultOptions: ExtractOptions = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nexport default function extractAbbreviation(line: string, pos: number = line.length, options: Partial<ExtractOptions> = {}): ExtractedAbbreviation | undefined {\n    // make sure `pos` is within line range\n    const opt: ExtractOptions = { ...defaultOptions, ...options };\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n\n    let ch: number;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack: number[] = [];\n\n    while (!sol(scanner)) {\n        ch = peek(scanner);\n\n        if (stack.includes(Brackets.CurlyR)) {\n            if (ch === Brackets.CurlyR) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n\n            if (ch !== Brackets.CurlyL) {\n                scanner.pos--;\n                continue;\n            }\n        }\n\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        } else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        } else if (stack.includes(Brackets.SquareR) || stack.includes(Brackets.CurlyR)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        } else if (isAtHTMLTag(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n\n        scanner.pos--;\n    }\n\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line: string, pos: number, options: ExtractOptions): number {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n\n    return pos;\n}\n\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line: string, pos: number, prefix: string): number {\n    if (!prefix) {\n        return 0;\n    }\n\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result: number;\n\n    while (!sol(scanner)) {\n        if (consumePair(scanner, Brackets.SquareR, Brackets.SquareL) || consumePair(scanner, Brackets.CurlyR, Brackets.CurlyL)) {\n            continue;\n        }\n\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n\n        scanner.pos--;\n    }\n\n    return -1;\n}\n\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner: BackwardScanner, close: number, open: number): boolean {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n\n            scanner.pos--;\n        }\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner: BackwardScanner, arr: number[]) {\n    const start = scanner.pos;\n    let consumed = false;\n\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n\n        consumed = i === 0;\n    }\n\n    if (!consumed) {\n        scanner.pos = start;\n    }\n\n    return consumed;\n}\n\nfunction isAbbreviation(ch: number) {\n    return (ch > 64 && ch < 91)   // uppercase letter\n        || (ch > 96 && ch < 123)  // lowercase letter\n        || (ch > 47 && ch < 58)   // number\n        || specialChars.includes(ch); // special character\n}\n\nfunction isOpenBrace(ch: number, syntax: SyntaxType) {\n    return ch === Brackets.RoundL || (syntax === 'markup' && (ch === Brackets.SquareL || ch === Brackets.CurlyL));\n}\n\nfunction isCloseBrace(ch: number, syntax: SyntaxType) {\n    return ch === Brackets.RoundR || (syntax === 'markup' && (ch === Brackets.SquareR || ch === Brackets.CurlyR));\n}\n","import markupAbbreviation, { Abbreviation } from '@emmetio/abbreviation';\nimport stylesheetAbbreviation, { CSSAbbreviation } from '@emmetio/css-abbreviation';\nimport parseMarkup, { stringify as stringifyMarkup } from './markup';\nimport parseStylesheet, {\n    stringify as stringifyStylesheet,\n    convertSnippets as parseStylesheetSnippets\n} from './stylesheet';\nimport resolveConfig, { UserConfig, Config } from './config';\nimport { CSSSnippet } from './stylesheet/snippets';\n\nexport default function expandAbbreviation(abbr: string, config?: UserConfig): string {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nexport function markup(abbr: string | Abbreviation, config: Config) {\n    return stringifyMarkup(parseMarkup(abbr, config), config);\n}\n\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nexport function stylesheet(abbr: string | CSSAbbreviation, config: Config, snippets?: CSSSnippet[]) {\n    return stringifyStylesheet(parseStylesheet(abbr, config, snippets), config);\n}\n\nexport {\n    markupAbbreviation, parseMarkup, stringifyMarkup,\n    stylesheetAbbreviation, parseStylesheet, stringifyStylesheet, parseStylesheetSnippets\n};\nexport { default as extract, ExtractOptions, ExtractedAbbreviation } from './extract-abbreviation';\nexport { GlobalConfig, SyntaxType, Config, UserConfig, Options, default as resolveConfig } from './config';\n"],"names":["isWhiteSpace","isQuote","isQuote$1","isNumber","isAlpha","isSpace","Scanner","ScannerError","tokenize","field","bracket","operator","whiteSpace","literal","consumePlaceholder","isLiteral","createLiteral","isBracket","operatorType","last","tokenScanner","peek","readable","consume","error","isSiblingOperator","isLiteral$1","isOpenBracket","isBracket$1","isOperator","parse","stringifyValue","walk","isField","splitByLines","element","shouldFormat","abbreviation","snippets","stringify","attributes","defaultOptions","isAtHTMLTag","stringifyMarkup","parseMarkup","stringifyStylesheet","parseStylesheet"],"mappings":"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"}